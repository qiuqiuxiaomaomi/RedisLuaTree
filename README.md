# RedisLuaTree
Redis +Lua实现分布式限流


<pre>
应用级限流方案：

      1、使用guava提供工具库里的RateLimiter类(内部采用令牌捅算法实现)进行限流 
      2、使用Java自带delayqueue的延迟队列实现(编码过程相对麻烦，此处省略代码) 
      3、使用Redis实现，存储两个key，一个用于计时，一个用于计数。请求每调用一次，计数器增
        加1，若在计时器时间内计数器未超过阈值，则可以处理任务 
</pre>

<pre>
可行性分析：

      最快捷且有效的方式是使用RateLimiter实现，但是这很容易踩到一个坑，单节点模式下，使用
      RateLimiter进行限流一点问题都没有。但是…线上是分布式系统，布署了多个节点，而且多个节
      点最终调用的是同一个短信服务商接口。虽然我们对单个节点能做到将QPS限制在400/s，但是多
      节点条件下，如果每个节点均是400/s，那么到服务商那边的总请求就是节点数x400/s，于是限
      流效果失效。使用该方案对单节点的阈值控制是难以适应分布式环境的，至少目前我还没想到更为
      合适的方式。 对于第二种，使用delayqueue方式。其实主要存在两个问题，
          1) 短信系统本身就用了一层消息，有用kafka或者其他MQ，如果再加上一层延迟队列，从
             设计上来说是不太合适的。
          2）实现delayqueue的过程相对比较麻烦，耗时可能不较长，而且达不到精准限流的效果。
          3）对于第三种，使用redis进行限流，其很好的解决了分布式环境下多实例所导致的并发
             问题，因为使用redis设置的计数器和计时器是全局唯一的，不管多少个节点，他们使用
             的都是同样的计时器和计数器，因此可以做到非常精准的流控，同时，这种方案编码并
             不复杂，可能需要的代码不超过10行。
</pre>

![](https://i.imgur.com/5sy9g5i.png)

<pre>
令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流
逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相
反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没
有Token可拿了就阻塞或者拒绝服务. 

令牌桶的另外一个好处是可以方便的改变速度. 一旦需要提高速率,则按需提高放入桶中的令牌的速率. 
一般会定时(比如100毫秒)往桶中增加一定数量的令牌, 有些变种算法则实时的计算应该增加的令牌的数量. 
</pre>

链接地址：
        https://www.cnblogs.com/duanxz/archive/2013/06/13/3134358.html